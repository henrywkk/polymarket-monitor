# Phase 3: Alert System & Delivery - Implementation Plan

**Goal:** Deliver alerts to users through multiple notification channels  
**Timeline:** Week 5-6 (7 days)  
**Status:** Ready to start

---

## Overview

Phase 3 builds on Phase 2's anomaly detection to deliver alerts to users. We'll create an alert dispatcher service that processes alerts from Redis, applies throttling, formats messages, and delivers them through multiple channels.

---

## Current State (Post-Phase 2)

‚úÖ **What We Have:**
- Alert events generated by `AnomalyDetector`
- Alerts stored in Redis:
  - `alerts:pending` - Queue of all pending alerts
  - `alerts:market:{marketId}` - Alerts per market
- Alert event structure defined:
  ```typescript
  interface AlertEvent {
    type: 'insider_move' | 'fat_finger' | 'liquidity_vacuum' | 'whale_trade' | 'volume_acceleration';
    marketId: string;
    outcomeId?: string;
    tokenId?: string;
    outcomeName?: string;
    severity: 'low' | 'medium' | 'high' | 'critical';
    message: string;
    data: Record<string, any>;
    timestamp: number;
  }
  ```

‚ùå **What We Need:**
- Alert dispatcher service to process alerts
- Alert throttling (prevent spam)
- Notification channels (webhook, email, etc.)
- Alert formatting (human-readable messages)
- Configuration system for thresholds and filters

---

## Task 1: Alert Dispatcher Service (2 days)

### 1.1 Create Alert Dispatcher Service

**File:** `backend/src/services/alert-dispatcher.ts`

**Responsibilities:**
- Poll Redis `alerts:pending` queue
- Process alerts one by one
- Apply throttling rules
- Format alerts into human-readable messages
- Route to appropriate notification channels
- Track delivery status

**Key Methods:**
```typescript
class AlertDispatcher {
  // Start processing alerts from queue
  start(): void;
  
  // Stop processing
  stop(): void;
  
  // Process a single alert
  private async processAlert(alert: AlertEvent): Promise<void>;
  
  // Format alert into human-readable message
  private formatAlert(alert: AlertEvent): FormattedAlert;
  
  // Route to notification channels
  private async deliverAlert(formattedAlert: FormattedAlert): Promise<void>;
  
  // Check if alert should be throttled
  private async shouldThrottle(alert: AlertEvent): Promise<boolean>;
}
```

**Implementation Steps:**
1. Create service class with Redis polling
2. Implement alert processing loop (poll every 1-2 seconds)
3. Add error handling and retry logic
4. Log processing status

### 1.2 Alert Formatting

**Format Structure:**
```typescript
interface FormattedAlert {
  title: string;           // "üö® INSIDER MOVE Detected"
  message: string;          // Human-readable description
  severity: string;         // "CRITICAL", "HIGH", etc.
  marketInfo: {
    marketId: string;
    marketName?: string;
    outcomeName?: string;
    category?: string;
  };
  metrics: {
    priceChange?: number;
    volumeZScore?: number;
    tradeSize?: number;
    spread?: number;
  };
  timestamp: string;        // ISO formatted
  polymarketUrl?: string;   // Link to market on Polymarket
}
```

**Formatting Rules:**
- **Insider Move**: "Price moved {X}% ({Y}pp) in <1min with {Z}œÉ volume spike"
- **Fat Finger**: "Price deviation of {X}% detected, reverted within 2 trades"
- **Liquidity Vacuum**: "Spread widened to {X} cents (depth: ${Y})"
- **Whale Trade**: "Large trade detected: ${X} USDC"
- **Volume Acceleration**: "Volume spike: {X}œÉ above average"

### 1.3 Integration with Market Data

**Enhancement:**
- Fetch market name from database when formatting
- Include outcome name if available
- Add Polymarket URL: `https://polymarket.com/event/{slug}`

---

## Task 2: Alert Throttling (1 day)

### 2.1 Throttling Logic

**File:** `backend/src/services/alert-throttle.ts`

**Rules:**
1. **Per-Market Cooldown**: 1 alert per market per 10 minutes (default)
2. **Severity Override**: Critical alerts bypass throttling
3. **Type-Based Throttling**: Different cooldowns per alert type
4. **Redis-Based**: Use Redis keys for cooldown tracking

**Implementation:**
```typescript
class AlertThrottle {
  // Check if alert should be throttled
  async shouldThrottle(alert: AlertEvent): Promise<boolean>;
  
  // Record alert delivery (set cooldown)
  async recordDelivery(alert: AlertEvent): Promise<void>;
  
  // Get time until next alert allowed
  async getTimeUntilNext(alert: AlertEvent): Promise<number>;
}
```

**Redis Keys:**
- `throttle:market:{marketId}` - Last alert timestamp per market
- `throttle:market:{marketId}:{type}` - Last alert timestamp per market+type

**Cooldown Durations:**
- Default: 10 minutes (600 seconds)
- Critical alerts: No cooldown
- High severity: 5 minutes
- Medium/Low: 10 minutes

### 2.2 Throttling Configuration

**Configurable via:**
- Environment variables
- `alert_config.json` (future)
- Per-alert-type overrides

---

## Task 3: Notification Channels (3 days)

### 3.1 Channel Abstraction

**File:** `backend/src/services/notification-channels.ts`

**Interface:**
```typescript
interface NotificationChannel {
  name: string;
  enabled: boolean;
  send(alert: FormattedAlert): Promise<boolean>;
}
```

### 3.2 Webhook Delivery (Priority 1)

**File:** `backend/src/services/channels/webhook-channel.ts`

**Features:**
- HTTP POST to configured webhook URL
- Retry logic (3 attempts with exponential backoff)
- Custom headers support
- Payload customization

**Configuration:**
```bash
# Environment variables
WEBHOOK_URL=https://your-webhook-endpoint.com/alerts
WEBHOOK_SECRET=your-secret-key
WEBHOOK_TIMEOUT=5000
WEBHOOK_RETRY_ATTEMPTS=3
```

**Payload Format:**
```json
{
  "alert": {
    "type": "insider_move",
    "severity": "critical",
    "title": "üö® INSIDER MOVE Detected",
    "message": "...",
    "marketId": "12345",
    "marketName": "Will X happen?",
    "outcomeName": "Yes",
    "timestamp": "2026-01-09T12:00:00Z",
    "polymarketUrl": "https://polymarket.com/event/..."
  },
  "metrics": {
    "priceChange": 32.5,
    "volumeZScore": 64.94
  },
  "signature": "hmac-sha256-signature"
}
```

### 3.3 Email Notifications (Optional, Priority 2)

**File:** `backend/src/services/channels/email-channel.ts`

**Features:**
- SMTP support (Gmail, SendGrid, etc.)
- HTML email templates
- Attachment support (charts, if needed)

**Configuration:**
```bash
EMAIL_ENABLED=true
EMAIL_SMTP_HOST=smtp.gmail.com
EMAIL_SMTP_PORT=587
EMAIL_USER=your-email@gmail.com
EMAIL_PASSWORD=your-password
EMAIL_FROM=alerts@polymarket-monitor.com
EMAIL_TO=recipient@example.com
```

**Email Template:**
- Subject: `[PolyMonitor] {Severity}: {Alert Type} - {Market Name}`
- Body: HTML formatted with alert details
- Include Polymarket link

### 3.4 In-App Notifications (Future, Priority 3)

**File:** `backend/src/services/channels/websocket-channel.ts`

**Features:**
- Broadcast alerts via existing WebSocket server
- Frontend subscribes to `alert` events
- Real-time alert display

**WebSocket Event:**
```typescript
socket.emit('alert', {
  type: 'insider_move',
  severity: 'critical',
  message: '...',
  marketId: '12345',
  timestamp: 1234567890
});
```

### 3.5 Push Notifications (Future, Priority 4)

**File:** `backend/src/services/channels/push-channel.ts`

**Features:**
- Firebase Cloud Messaging (FCM)
- Apple Push Notification Service (APNS)
- Web Push (PWA)

**Note:** Implementation deferred to future phase

---

## Task 4: Alert Configuration (1 day)

### 4.1 Configuration File

**File:** `backend/src/config/alert-config.ts`

**Structure:**
```typescript
interface AlertConfig {
  throttling: {
    defaultCooldownSeconds: number;
    cooldownsByType: Record<string, number>;
    severityOverrides: {
      critical: boolean; // Bypass throttling
      high: number;      // Cooldown in seconds
      medium: number;
      low: number;
    };
  };
  channels: {
    webhook: {
      enabled: boolean;
      url?: string;
      secret?: string;
    };
    email: {
      enabled: boolean;
      smtp?: SMTPConfig;
    };
    websocket: {
      enabled: boolean;
    };
  };
  filters: {
    minSeverity: 'low' | 'medium' | 'high' | 'critical';
    categories?: string[]; // Only alert for these categories
    minVolume?: number;     // Only alert for markets with min volume
  };
  thresholds: {
    // Can override AnomalyDetector thresholds if needed
    priceVelocity?: number;
    fatFinger?: number;
    liquidityVacuum?: number;
    whaleTrade?: number;
  };
}
```

### 4.2 Environment Variable Support

**Priority:** Use environment variables for initial implementation
- Configuration file can be added later for more complex setups

**Key Variables:**
```bash
# Throttling
ALERT_THROTTLE_COOLDOWN=600
ALERT_CRITICAL_BYPASS_THROTTLE=true

# Channels
WEBHOOK_ENABLED=true
WEBHOOK_URL=https://...
EMAIL_ENABLED=false

# Filters
ALERT_MIN_SEVERITY=medium
ALERT_CATEGORIES=crypto,politics
```

---

## Integration Points

### 4.1 Main Application Integration

**File:** `backend/src/index.ts`

**Changes:**
```typescript
import { AlertDispatcher } from './services/alert-dispatcher';

// Initialize alert dispatcher
const alertDispatcher = new AlertDispatcher(
  redis,
  notificationChannels,
  alertThrottle
);

// Start dispatcher after server starts
alertDispatcher.start();
```

### 4.2 API Endpoints (Optional)

**File:** `backend/src/routes/alerts.ts`

**Endpoints:**
- `GET /api/alerts` - List recent alerts
- `GET /api/alerts/:marketId` - Alerts for specific market
- `POST /api/alerts/test` - Trigger test alert
- `GET /api/alerts/stats` - Alert statistics

---

## Testing Strategy

### 5.1 Unit Tests
- Alert formatting logic
- Throttling rules
- Channel delivery

### 5.2 Integration Tests
- End-to-end alert flow
- Webhook delivery
- Throttling behavior

### 5.3 Manual Testing
- Trigger test alerts
- Verify webhook delivery
- Check throttling works
- Verify message formatting

---

## Deliverables

‚úÖ **Alert Dispatcher Service**
- Processes alerts from Redis queue
- Formats alerts into human-readable messages
- Routes to notification channels

‚úÖ **Alert Throttling**
- Prevents spam (1 alert per market per 10min)
- Severity-based overrides
- Redis-based cooldown tracking

‚úÖ **Notification Channels**
- Webhook delivery (fully implemented)
- Email notifications (optional, if configured)
- WebSocket broadcasting (for frontend)
- Extensible for future channels

‚úÖ **Configuration System**
- Environment variable support
- Configurable thresholds and filters
- Channel enable/disable

---

## Success Criteria

1. ‚úÖ Alerts processed from Redis queue within 5 seconds
2. ‚úÖ Throttling prevents duplicate alerts (1 per market per 10min)
3. ‚úÖ Webhook delivery successful with retry logic
4. ‚úÖ Alert messages are human-readable and informative
5. ‚úÖ Critical alerts bypass throttling
6. ‚úÖ Configuration system allows customization
7. ‚úÖ Error handling prevents alert loss

---

## Dependencies

- Phase 2 completed (anomaly detection working)
- Redis operational
- Database accessible (for market name lookup)
- Webhook endpoint available (for testing)

---

## Next Steps After Phase 3

Once Phase 3 is complete:
1. **Phase 4: New Market/Outcome Detection**
   - Detect new markets and outcomes
   - Trigger "New Narrative" alerts

2. **Monitoring & Observability**
   - Alert delivery metrics
   - Success/failure rates
   - Dashboard for alert statistics

3. **User Preferences**
   - User-specific alert filters
   - Custom notification channels
   - Alert preferences API
